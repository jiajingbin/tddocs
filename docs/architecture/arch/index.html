<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/tddocs/blog/rss.xml" title="TDengine 学习笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/tddocs/blog/atom.xml" title="TDengine 学习笔记 Atom Feed"><title data-react-helmet="true">数据模型和整体架构 | TDengine 学习笔记</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://dingbo8128.github.io/tddocs/docs/architecture/arch"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="数据模型和整体架构 | TDengine 学习笔记"><meta data-react-helmet="true" name="description" content="数据模型"><meta data-react-helmet="true" property="og:description" content="数据模型"><link data-react-helmet="true" rel="icon" href="/tddocs/img/docusaurus.ico"><link data-react-helmet="true" rel="canonical" href="https://dingbo8128.github.io/tddocs/docs/architecture/arch"><link data-react-helmet="true" rel="alternate" href="https://dingbo8128.github.io/tddocs/docs/architecture/arch" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://dingbo8128.github.io/tddocs/docs/architecture/arch" hreflang="x-default"><link rel="stylesheet" href="/tddocs/assets/css/styles.8cea5e31.css">
<link rel="preload" href="/tddocs/assets/js/runtime~main.9709ac72.js" as="script">
<link rel="preload" href="/tddocs/assets/js/main.0d693db3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/tddocs/"><div class="navbar__logo"><img src="/tddocs/img/logo.jpg" alt="TDengine" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/tddocs/img/logo.jpg" alt="TDengine" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">TDengine</b></a><a class="navbar__item navbar__link navbar__link--active" href="/tddocs/docs/intro">文档</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/taosdata/TDengine" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/intro">TDengine 介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/tddocs/docs/getting-started/get-started">快速入门</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/tddocs/docs/architecture/arch">整体架构</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/tddocs/docs/architecture/arch">数据模型和整体架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/tddocs/docs/architecture/taosd">taosd的设计</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/tddocs/docs/architecture/replica">数据复制模块设计</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/model">数据建模</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/tddocs/docs/taos-sql/tsql">SQL手册</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/insert">高效写入</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/query">高效查询</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/advance-feature">高级功能</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/tddocs/docs/connector/">连接器</a><button aria-label="Toggle the collapsible sidebar category &#x27;连接器&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/connections">与其他工具的连接</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/cluster">TDengine 集群安装、管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tddocs/docs/operation">TDengine 的运营与维护</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_cwdi"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_xORG"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>数据模型和整体架构</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="数据模型">数据模型<a class="hash-link" href="#数据模型" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="物联网典型场景">物联网典型场景<a class="hash-link" href="#物联网典型场景" title="Direct link to heading">​</a></h3><p>在典型的物联网、车联网、运维监测场景中，往往有多种不同类型的数据采集设备，采集一个到多个不同的物理量。而同一种采集设备类型，往往又有多个具体的采集设备分布在不同的地点。大数据处理系统就是要将各种采集的数据汇总，然后进行计算和分析。对于同一类设备，其采集的数据都是很规则的。以智能电表为例，假设每个智能电表采集电流、电压、相位三个量，其采集的数据类似如下的表格：</p><a class="anchor" id="model_table1"></a><table><thead><tr><th>设备ID</th><th>时间戳</th><th colspan="3">采集量</th><th colspan="2">标签</th></tr><tr><th>Device ID</th><th>Time Stamp</th><th>current</th><th>voltage</th><th>phase</th><th>location</th><th>groupId</th></tr></thead><tbody><tr><td>d1001</td><td>1538548685000</td><td>10.3</td><td>219</td><td>0.31</td><td>Beijing.Chaoyang</td><td>2</td></tr><tr><td>d1002</td><td>1538548684000</td><td>10.2</td><td>220</td><td>0.23</td><td>Beijing.Chaoyang</td><td>3</td></tr><tr><td>d1003</td><td>1538548686500</td><td>11.5</td><td>221</td><td>0.35</td><td>Beijing.Haidian</td><td>3</td></tr><tr><td>d1004</td><td>1538548685500</td><td>13.4</td><td>223</td><td>0.29</td><td>Beijing.Haidian</td><td>2</td></tr><tr><td>d1001</td><td>1538548695000</td><td>12.6</td><td>218</td><td>0.33</td><td>Beijing.Chaoyang</td><td>2</td></tr><tr><td>d1004</td><td>1538548696600</td><td>11.8</td><td>221</td><td>0.28</td><td>Beijing.Haidian</td><td>2</td></tr><tr><td>d1002</td><td>1538548696650</td><td>10.3</td><td>218</td><td>0.25</td><td>Beijing.Chaoyang</td><td>3</td></tr><tr><td>d1001</td><td>1538548696800</td><td>12.3</td><td>221</td><td>0.31</td><td>Beijing.Chaoyang</td><td>2</td></tr></tbody></table><center> 表 1：智能电表数据示例</center><p>每一条记录都有设备 ID，时间戳，采集的物理量（如上图中的电流、电压、相位），还有与每个设备相关的静态标签（如上述表1中的位置 Location 和分组 groupId）。每个设备是受外界的触发，或按照设定的周期采集数据。采集的数据点是时序的，是一个数据流。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="数据特征">数据特征<a class="hash-link" href="#数据特征" title="Direct link to heading">​</a></h3><p>除时序特征外，仔细研究发现，物联网、车联网、运维监测类数据还具有很多其他明显的特征：</p><ol><li>数据高度结构化；</li><li>数据极少有更新或删除操作；</li><li>无需传统数据库的事务处理；</li><li>相对互联网应用，写多读少；</li><li>流量平稳，根据设备数量和采集频次，可以预测出来；</li><li>用户关注的是一段时间的趋势，而不是某一特定时间点的值；</li><li>数据有保留期限；</li><li>数据的查询分析一定是基于时间段和空间区域；</li><li>除存储、查询操作外，还需要各种统计和实时计算操作；</li><li>数据量巨大，一天可能采集的数据就可以超过 100 亿条。</li></ol><p>充分利用上述特征，TDengine 采取了经特殊优化的存储和计算设计来处理时序数据，它将系统处理能力显著提高，同时大幅降低了系统运维的复杂度。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="关系型数据库模型">关系型数据库模型<a class="hash-link" href="#关系型数据库模型" title="Direct link to heading">​</a></h3><p>因为采集的数据一般是结构化数据，同时为降低学习门槛，TDengine 采用传统的关系型数据库模型管理数据。因此用户需要先创建库，然后创建表，之后才能插入或查询数据。TDengine 采用的是结构化存储，而不是 NoSQL 的 key-value 存储。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="一个数据采集点一张表">一个数据采集点一张表<a class="hash-link" href="#一个数据采集点一张表" title="Direct link to heading">​</a></h3><p>为充分利用其数据的时序性和其他数据特点，TDengine 要求<strong>对每个数据采集点单独建表</strong>（比如有一千万个智能电表，就需创建一千万张表，上述表格中的 d1001, d1002, d1003, d1004 都需单独建表），用来存储这个采集点所采集的时序数据。这种设计有几大优点：</p><ol><li>能保证一个采集点的数据在存储介质上是以块为单位连续存储的。如果读取一个时间段的数据，它能大幅减少随机读取操作，成数量级的提升读取和查询速度。</li><li>由于不同采集设备产生数据的过程完全独立，每个设备的数据源是唯一的，一张表也就只有一个写入者，这样就可采用无锁方式来写，写入速度就能大幅提升。</li><li>对于一个数据采集点而言，其产生的数据是时序的，因此写的操作可用追加的方式实现，进一步大幅提高数据写入速度。</li></ol><p>如果采用传统的方式，将多个设备的数据写入一张表，由于网络延时不可控，不同设备的数据到达服务器的时序是无法保证的，写入操作是要有锁保护的，而且一个设备的数据是难以保证连续存储在一起的。<strong>采用一个数据采集点一张表的方式，能最大程度的保证单个数据采集点的插入和查询的性能是最优的。</strong></p><p>TDengine 建议用数据采集点的名字(如上表中的 D1001)来做表名。每个数据采集点可能同时采集多个物理量(如上表中的 curent, voltage, phase)，每个物理量对应一张表中的一列，数据类型可以是整型、浮点型、字符串等。除此之外，表的第一列必须是时间戳，即数据类型为 timestamp。对采集的数据，TDengine 将自动按照时间戳建立索引，但对采集的物理量不建任何索引。数据用列式存储方式保存。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="超级表同一类型数据采集点的集合">超级表：同一类型数据采集点的集合<a class="hash-link" href="#超级表同一类型数据采集点的集合" title="Direct link to heading">​</a></h3><p>由于一个数据采集点一张表，导致表的数量巨增，难以管理，而且应用经常需要做采集点之间的聚合操作，聚合的操作也变得复杂起来。为解决这个问题，TDengine 引入超级表(Super Table，简称为 STable)的概念。</p><p>超级表是指某一特定类型的数据采集点的集合。同一类型的数据采集点，其表的结构是完全一样的，但每个表（数据采集点）的静态属性（标签）是不一样的。描述一个超级表（某一特定类型的数据采集点的集合），除需要定义采集量的表结构之外，还需要定义其标签的 schema，标签的数据类型可以是整数、浮点数、字符串，标签可以有多个，可以事后增加、删除或修改。如果整个系统有 N 个不同类型的数据采集点，就需要建立 N 个超级表。</p><p>在 TDengine 的设计里，<strong>表用来代表一个具体的数据采集点，超级表用来代表一组相同类型的数据采集点集合</strong>。当为某个具体数据采集点创建表时，用户使用超级表的定义做模板，同时指定该具体采集点（表）的标签值。与传统的关系型数据库相比，表（一个数据采集点）是带有静态标签的，而且这些标签可以事后增加、删除、修改。<strong>一张超级表包含有多张表，这些表具有相同的时序数据 schema，但带有不同的标签值</strong>。</p><p>当对多个具有相同数据类型的数据采集点进行聚合操作时，TDengine 会先把满足标签过滤条件的表从超级表中找出来，然后再扫描这些表的时序数据，进行聚合操作，这样需要扫描的数据集会大幅减少，从而显著提高聚合计算的性能。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="集群与基本逻辑单元">集群与基本逻辑单元<a class="hash-link" href="#集群与基本逻辑单元" title="Direct link to heading">​</a></h2><p>TDengine 的设计是基于单个硬件、软件系统不可靠，基于任何单台计算机都无法提供足够计算能力和存储能力处理海量数据的假设进行设计的。因此 TDengine 从研发的第一天起，就按照分布式高可靠架构进行设计，是支持水平扩展的，这样任何单台或多台服务器发生硬件故障或软件错误都不影响系统的可用性和可靠性。同时，通过节点虚拟化并辅以自动化负载均衡技术，TDengine 能最高效率地利用异构集群中的计算和存储资源降低硬件投资。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="主要逻辑单元">主要逻辑单元<a class="hash-link" href="#主要逻辑单元" title="Direct link to heading">​</a></h3><p>TDengine 分布式架构的逻辑结构图如下：</p><p><img alt="TDengine架构示意图" src="/tddocs/assets/images/structure-74b417b6f17c1eb3ff847e8409aa4538.png" width="968" height="600"></p><center> 图 1 TDengine架构示意图  </center><p>一个完整的 TDengine 系统是运行在一到多个物理节点上的，逻辑上，它包含数据节点(dnode)、TDengine 应用驱动(taosc)以及应用(app)。系统中存在一到多个数据节点，这些数据节点组成一个集群(cluster)。应用通过 taosc 的 API 与 TDengine 集群进行互动。下面对每个逻辑单元进行简要介绍。</p><p><strong>物理节点(pnode)：</strong> pnode 是一独立运行、拥有自己的计算、存储和网络能力的计算机，可以是安装有OS的物理机、虚拟机或 Docker 容器。物理节点由其配置的 FQDN (Fully Qualified Domain Name)来标识。TDengine 完全依赖 FQDN 来进行网络通讯，如果不了解 FQDN，请看博文<a href="https://www.taosdata.com/blog/2020/09/11/1824.html" target="_blank" rel="noopener noreferrer">《一篇文章说清楚 TDengine 的 FQDN》</a>。</p><p><strong>数据节点(dnode)：</strong> dnode 是 TDengine 服务器侧执行代码 taosd 在物理节点上的一个运行实例，一个工作的系统必须有至少一个数据节点。dnode 包含零到多个逻辑的虚拟节点(vnode)，零或者至多一个逻辑的管理节点(mnode)。dnode 在系统中的唯一标识由实例的 End Point (EP)决定。EP 是 dnode 所在物理节点的 FQDN (Fully Qualified Domain Name)和系统所配置的网络端口号(Port)的组合。通过配置不同的端口，一个物理节点(一台物理机、虚拟机或容器）可以运行多个实例，或有多个数据节点。</p><p><strong>虚拟节点(vnode)：</strong> 为更好的支持数据分片、负载均衡，防止数据过热或倾斜，数据节点被虚拟化成多个虚拟节点(vnode，图中 V2, V3, V4等)。每个 vnode 都是一个相对独立的工作单元，是时序数据存储的基本单元，具有独立的运行线程、内存空间与持久化存储的路径。一个 vnode 包含一定数量的表（数据采集点）。当创建一张新表时，系统会检查是否需要创建新的 vnode。一个数据节点上能创建的 vnode 的数量取决于该数据节点所在物理节点的硬件资源。一个 vnode 只属于一个 DB，但一个 DB 可以有多个 vnode。一个 vnode 除存储的时序数据外，也保存有所包含的表的 schema、标签值等。一个虚拟节点由所属的数据节点的EP，以及所属的 VGroup ID 在系统内唯一标识，由管理节点创建并管理。</p><p><strong>管理节点(mnode)：</strong> 一个虚拟的逻辑单元，负责所有数据节点运行状态的监控和维护，以及节点之间的负载均衡(图中 M)。同时，管理节点也负责元数据(包括用户、数据库、表、静态标签等)的存储和管理，因此也称为 Meta Node。TDengine 集群中可配置多个(开源版最多不超过 3 个) mnode，它们自动构建成为一个虚拟管理节点组(图中 M0, M1, M2)。mnode 间采用 master/slave 的机制进行管理，而且采取强一致方式进行数据同步, 任何数据更新操作只能在 Master 上进行。mnode 集群的创建由系统自动完成，无需人工干预。每个 dnode 上至多有一个 mnode，由所属的数据节点的EP来唯一标识。每个 dnode 通过内部消息交互自动获取整个集群中所有 mnode 所在的 dnode 的EP。</p><p><strong>虚拟节点组(VGroup)：</strong> 不同数据节点上的 vnode 可以组成一个虚拟节点组(vnode group)来保证系统的高可靠。虚拟节点组内采取 master/slave 的方式进行管理。写操作只能在 master vnode 上进行，系统采用异步复制的方式将数据同步到 slave vnode，这样确保了一份数据在多个物理节点上有拷贝。一个 vgroup 里虚拟节点个数就是数据的副本数。如果一个 DB 的副本数为 N，系统必须有至少 N 数据节点。副本数在创建DB时通过参数 replica 可以指定，缺省为 1。使用 TDengine 的多副本特性，可以不再需要昂贵的磁盘阵列等存储设备，就可以获得同样的数据高可靠性。虚拟节点组由管理节点创建、管理，并且由管理节点分配一个系统唯一的 ID，VGroup ID。如果两个虚拟节点的 vnode group ID 相同，说明他们属于同一个组，数据互为备份。虚拟节点组里虚拟节点的个数是可以动态改变的，容许只有一个，也就是没有数据复制。VGroup ID 是永远不变的，即使一个虚拟节点组被删除，它的ID也不会被收回重复利用。</p><p><strong>TAOSC：</strong> taosc 是 TDengine 给应用提供的驱动程序(driver)，负责处理应用与集群的接口交互，提供 C/C++ 语言原生接口，内嵌于 JDBC、C#、Python、Go、Node.js 语言连接库里。应用都是通过 taosc 而不是直接连接集群中的数据节点与整个集群进行交互的。这个模块负责获取并缓存元数据；将插入、查询等请求转发到正确的数据节点；在把结果返回给应用时，还需要负责最后一级的聚合、排序、过滤等操作。对于 JDBC、C/C++、C#、Python、Go、Node.js 接口而言，这个模块是在应用所处的物理节点上运行。同时，为支持全分布式的 RESTful 接口，taosc 在 TDengine 集群的每个 dnode 上都有一运行实例。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="节点之间的通讯">节点之间的通讯<a class="hash-link" href="#节点之间的通讯" title="Direct link to heading">​</a></h3><p><strong>通讯方式：</strong>TDengine 系统的各个数据节点之间，以及应用驱动与各数据节点之间的通讯是通过 TCP/UDP 进行的。因为考虑到物联网场景，数据写入的包一般不大，因此 TDengine 除采用 TCP 做传输之外，还采用 UDP 方式，因为 UDP 更加高效，而且不受连接数的限制。TDengine 实现了自己的超时、重传、确认等机制，以确保 UDP 的可靠传输。对于数据量不到15K的数据包，采取 UDP 的方式进行传输，超过 15K 的，或者是查询类的操作，自动采取 TCP 的方式进行传输。同时，TDengine 根据配置和数据包，会自动对数据进行压缩/解压缩，数字签名/认证等处理。对于数据节点之间的数据复制，只采用 TCP 方式进行数据传输。</p><p><strong>FQDN配置：</strong>一个数据节点有一个或多个 FQDN，可以在系统配置文件 taos.cfg 通过参数&quot;fqdn&quot;进行指定，如果没有指定，系统将自动获取计算机的 hostname 作为其 FQDN。如果节点没有配置 FQDN，可以直接将该节点的配置参数 fqdn 设置为它的IP地址。但不建议使用 IP，因为 IP 地址可变，一旦变化，将让集群无法正常工作。一个数据节点的 EP(End Point) 由 FQDN + Port 组成。采用 FQDN，需要保证 DNS 服务正常工作，或者在节点以及应用所在的节点配置好 hosts 文件。另外，这个参数值的长度需要控制在 96 个字符以内。</p><p><strong>端口配置：</strong>一个数据节点对外的端口由 TDengine 的系统配置参数 serverPort 决定，对集群内部通讯的端口是 serverPort+5。为支持多线程高效的处理 UDP 数据，每个对内和对外的 UDP 连接，都需要占用5个连续的端口。</p><ul><li>集群内数据节点之间的数据复制操作占用一个 TCP 端口，是 serverPort+10。</li><li>集群数据节点对外提供 RESTful 服务占用一个 TCP 端口，是 serverPort+11。</li><li>集群内数据节点与 Arbitrator 节点之间通讯占用一个 TCP 端口，是 serverPort+12。</li></ul><p>因此一个数据节点总的端口范围为 serverPort 到 serverPort+12，总共 13 个 TCP/UDP 端口。使用时，需要确保防火墙将这些端口打开。每个数据节点可以配置不同的 serverPort。（详细的端口情况请参见 <a href="https://www.taosdata.com/cn/documentation/faq#port" target="_blank" rel="noopener noreferrer">TDengine 2.0 端口说明</a>）</p><p><strong>集群对外连接：</strong>TDengine 集群可以容纳单个、多个甚至几千个数据节点。应用只需要向集群中任何一个数据节点发起连接即可，连接需要提供的网络参数是一数据节点的 End Point(FQDN加配置的端口号）。通过命令行CLI启动应用 taos 时，可以通过选项-h来指定数据节点的 FQDN, -P 来指定其配置的端口号，如果端口不配置，将采用 TDengine 的系统配置参数 serverPort。</p><p><strong>集群内部通讯：</strong>各个数据节点之间通过 TCP/UDP 进行连接。一个数据节点启动时，将获取 mnode 所在的 dnode 的 EP 信息，然后与系统中的 mnode 建立起连接，交换信息。获取 mnode 的 EP 信息有三步：</p><ol><li>检查 mnodeEpSet.json 文件是否存在，如果不存在或不能正常打开获得 mnode EP 信息，进入第二步；</li><li>检查系统配置文件 taos.cfg，获取节点配置参数 firstEp、secondEp（这两个参数指定的节点可以是不带 mnode 的普通节点，这样的话，节点被连接时会尝试重定向到 mnode 节点），如果不存在或者 taos.cfg 里没有这两个配置参数，或无效，进入第三步；</li><li>将自己的EP设为 mnode EP，并独立运行起来。</li></ol><p>获取 mnode EP 列表后，数据节点发起连接，如果连接成功，则成功加入进工作的集群，如果不成功，则尝试 mnode EP 列表中的下一个。如果都尝试了，但连接都仍然失败，则休眠几秒后，再进行尝试。</p><p><strong>MNODE的选择：</strong>TDengine 逻辑上有管理节点，但没有单独的执行代码，服务器侧只有一套执行代码 taosd。那么哪个数据节点会是管理节点呢？这是系统自动决定的，无需任何人工干预。原则如下：一个数据节点启动时，会检查自己的 End Point, 并与获取的 mnode EP List 进行比对，如果在其中，该数据节点认为自己应该启动 mnode 模块，成为 mnode。如果自己的 EP 不在 mnode EP List 里，则不启动 mnode 模块。在系统的运行过程中，由于负载均衡、宕机等原因，mnode 有可能迁移至新的 dnode，但一切都是透明的，无需人工干预，配置参数的修改，是 mnode 自己根据资源做出的决定。</p><p><strong>新数据节点的加入：</strong>系统有了一个数据节点后，就已经成为一个工作的系统。添加新的节点进集群时，有两个步骤，第一步：使用 TDengine CLI 连接到现有工作的数据节点，然后用命令&quot;create dnode&quot;将新的数据节点的 End Point 添加进去; 第二步：在新的数据节点的系统配置参数文件 taos.cfg 里，将 firstEp, secondEp 参数设置为现有集群中任意两个数据节点的 EP 即可。具体添加的详细步骤请见详细的用户手册。这样就把集群一步一步的建立起来。</p><p><strong>重定向：</strong>无论是 dnode 还是 taosc，最先都是要发起与 mnode 的连接，但 mnode 是系统自动创建并维护的，因此对于用户来说，并不知道哪个 dnode 在运行 mnode。TDengine 只要求向系统中任何一个工作的 dnode 发起连接即可。因为任何一个正在运行的 dnode，都维护有目前运行的 mnode EP List。当收到一个来自新启动的 dnode 或 taosc 的连接请求，如果自己不是 mnode，则将 mnode EP List 回复给对方，taosc 或新启动的 dnode 收到这个 list, 就重新尝试建立连接。当 mnode EP List 发生改变，通过节点之间的消息交互，各个数据节点就很快获取最新列表，并通知 taosc。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="一个典型的消息流程">一个典型的消息流程<a class="hash-link" href="#一个典型的消息流程" title="Direct link to heading">​</a></h3><p>为解释 vnode、mnode、taosc 和应用之间的关系以及各自扮演的角色，下面对写入数据这个典型操作的流程进行剖析。</p><p><img alt="TDengine典型的操作流程" src="/tddocs/assets/images/message-60182a7035ccca6cf0025d77a752e5d1.png" width="1154" height="543"></p><center> 图 2 TDengine 典型的操作流程 </center><ol><li>应用通过 JDBC 或其他API接口发起插入数据的请求。</li><li>taosc 会检查缓存，看是否保存有该表的 meta data。如果有，直接到第 4 步。如果没有，taosc 将向 mnode 发出 get meta-data 请求。</li><li>mnode 将该表的 meta-data 返回给 taosc。Meta-data 包含有该表的 schema, 而且还有该表所属的 vgroup信息（vnode ID 以及所在的 dnode 的 End Point，如果副本数为 N，就有 N 组 End Point)。如果 taosc 迟迟得不到 mnode 回应，而且存在多个 mnode, taosc 将向下一个 mnode 发出请求。</li><li>taosc 向 master vnode 发起插入请求。</li><li>vnode 插入数据后，给 taosc 一个应答，表示插入成功。如果 taosc 迟迟得不到 vnode 的回应，taosc 会认为该节点已经离线。这种情况下，如果被插入的数据库有多个副本，taosc 将向 vgroup 里下一个 vnode 发出插入请求。</li><li>taosc 通知 APP，写入成功。</li></ol><p>对于第二和第三步，taosc 启动时，并不知道 mnode 的 End Point，因此会直接向配置的集群对外服务的 End Point 发起请求。如果接收到该请求的 dnode 并没有配置 mnode，该 dnode 会在回复的消息中告知mnode EP 列表，这样 taosc 会重新向新的 mnode 的 EP 发出获取 meta-data 的请求。</p><p>对于第四和第五步，没有缓存的情况下，taosc 无法知道虚拟节点组里谁是 master，就假设第一个 vnodeID 就是 master,向它发出请求。如果接收到请求的 vnode 并不是 master,它会在回复中告知谁是 master，这样 taosc 就向建议的 master vnode 发出请求。一旦得到插入成功的回复，taosc 会缓存 master 节点的信息。</p><p>上述是插入数据的流程，查询、计算的流程也完全一致。taosc 把这些复杂的流程全部封装屏蔽了，对于应用来说无感知也无需任何特别处理。</p><p>通过 taosc 缓存机制，只有在第一次对一张表操作时，才需要访问 mnode，因此 mnode 不会成为系统瓶颈。但因为 schema 有可能变化，而且 vgroup 有可能发生改变（比如负载均衡发生），因此 taosc 会定时和mnode 交互，自动更新缓存。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="存储模型与数据分区分片"><a class="anchor" id="sharding"></a>存储模型与数据分区、分片<a class="hash-link" href="#存储模型与数据分区分片" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="存储模型">存储模型<a class="hash-link" href="#存储模型" title="Direct link to heading">​</a></h3><p>TDengine 存储的数据包括采集的时序数据以及库、表相关的元数据、标签数据等，这些数据具体分为三部分：</p><ul><li>时序数据：存放于 vnode 里，由 data、head 和 last 三个文件组成，数据量大，查询量取决于应用场景。容许乱序写入，但暂时不支持删除操作，并且仅在 update 参数设置为 1 时允许更新操作。通过采用一个采集点一张表的模型，一个时间段的数据是连续存储，对单张表的写入是简单的追加操作，一次读，可以读到多条记录，这样保证对单个采集点的插入和查询操作，性能达到最优。</li><li>标签数据：存放于 vnode 里的 meta 文件，支持增删改查四个标准操作。数据量不大，有 N 张表，就有 N 条记录，因此可以全内存存储。如果标签过滤操作很多，查询将十分频繁，因此 TDengine 支持多核多线程并发查询。只要计算资源足够，即使有数千万张表，过滤结果能毫秒级返回。</li><li>元数据：存放于 mnode 里，包含系统节点、用户、DB、Table Schema 等信息，支持增删改查四个标准操作。这部分数据的量不大，可以全内存保存，而且由于客户端有缓存，查询量也不大。因此目前的设计虽是集中式存储管理，但不会构成性能瓶颈。</li></ul><p>与典型的 NoSQL 存储模型相比，TDengine 将标签数据与时序数据完全分离存储，它具有两大优势：</p><ul><li>能够极大地降低标签数据存储的冗余度：一般的 NoSQL 数据库或时序数据库，采用的 K-V 存储，其中的 Key 包含时间戳、设备 ID、各种标签。每条记录都带有这些重复的内容，浪费存储空间。而且如果应用要在历史数据上增加、修改或删除标签，需要遍历数据，重写一遍，操作成本极其昂贵。</li><li>能够实现极为高效的多表之间的聚合查询：做多表之间聚合查询时，先把符合标签过滤条件的表查找出来，然后再查找这些表相应的数据块，这样大幅减少要扫描的数据集，从而大幅提高查询效率。而且标签数据采用全内存的结构进行管理和维护，千万级别规模的标签数据查询可以在毫秒级别返回。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="数据分片">数据分片<a class="hash-link" href="#数据分片" title="Direct link to heading">​</a></h3><p>对于海量的数据管理，为实现水平扩展，一般都需要采取分片(Sharding)分区(Partitioning)策略。TDengine 是通过 vnode 来实现数据分片的，通过一个时间段一个数据文件来实现时序数据分区的。</p><p>vnode(虚拟数据节点)负责为采集的时序数据提供写入、查询和计算功能。为便于负载均衡、数据恢复、支持异构环境，TDengine 将一个数据节点根据其计算和存储资源切分为多个 vnode。这些 vnode 的管理是TDengine 自动完成的，对应用完全透明。</p><p>对于单独一个数据采集点，无论其数据量多大，一个 vnode（或 vnode group, 如果副本数大于 1）有足够的计算资源和存储资源来处理（如果每秒生成一条 16 字节的记录，一年产生的原始数据不到 0.5G），因此 TDengine 将一张表（一个数据采集点）的所有数据都存放在一个 vnode 里，而不会让同一个采集点的数据分布到两个或多个 dnode 上。而且一个 vnode 可存储多个数据采集点(表）的数据，一个 vnode 可容纳的表的数目的上限为一百万。设计上，一个 vnode 里所有的表都属于同一个 DB。一个数据节点上，除非特殊配置，一个 DB 拥有的 vnode 数目不会超过系统核的数目。</p><p>创建 DB 时，系统并不会马上分配资源。但当创建一张表时，系统将看是否有已经分配的 vnode, 且该 vnode 是否有空余的表空间，如果有，立即在该有空位的 vnode 创建表。如果没有，系统将从集群中，根据当前的负载情况，在一个 dnode 上创建一新的 vnode, 然后创建表。如果DB有多个副本，系统不是只创建一个 vnode，而是一个 vgroup (虚拟数据节点组)。系统对 vnode 的数目没有任何限制，仅仅受限于物理节点本身的计算和存储资源。</p><p>每张表的 meta data（包含 schema, 标签等）也存放于 vnode 里，而不是集中存放于 mnode，实际上这是对 Meta 数据的分片，这样便于高效并行的进行标签过滤操作。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="数据分区">数据分区<a class="hash-link" href="#数据分区" title="Direct link to heading">​</a></h3><p>TDengine 除 vnode 分片之外，还对时序数据按照时间段进行分区。每个数据文件只包含一个时间段的时序数据，时间段的长度由 DB 的配置参数 days 决定。这种按时间段分区的方法还便于高效实现数据的保留策略，只要数据文件超过规定的天数（系统配置参数 keep)，将被自动删除。而且不同的时间段可以存放于不同的路径和存储介质，以便于大数据的冷热管理，实现多级存储。</p><p>总的来说，<strong>TDengine 是通过 vnode 以及时间两个维度，对大数据进行切分</strong>，便于并行高效的管理，实现水平扩展。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="负载均衡">负载均衡<a class="hash-link" href="#负载均衡" title="Direct link to heading">​</a></h3><p>每个 dnode 都定时向 mnode(虚拟管理节点)报告其状态（包括硬盘空间、内存大小、CPU、网络、虚拟节点个数等），因此 mnode 了解整个集群的状态。基于整体状态，当 mnode 发现某个dnode负载过重，它会将dnode 上的一个或多个 vnode 挪到其他 dnode。在挪动过程中，对外服务继续进行，数据插入、查询和计算操作都不受影响。</p><p>如果 mnode 一段时间没有收到 dnode 的状态报告，mnode 会认为这个 dnode 已经离线。如果离线时间超过一定时长（时长由配置参数 offlineThreshold 决定），该 dnode 将被 mnode 强制剔除出集群。该dnode 上的 vnodes 如果副本数大于 1，系统将自动在其他 dnode 上创建新的副本，以保证数据的副本数。如果该 dnode 上还有 mnode, 而且 mnode 的副本数大于1，系统也将自动在其他 dnode 上创建新的 mnode, 以保证 mnode 的副本数。</p><p>当新的数据节点被添加进集群，因为新的计算和存储被添加进来，系统也将自动启动负载均衡流程。</p><p>负载均衡过程无需任何人工干预，应用也无需重启，将自动连接新的节点，完全透明。</p><p><strong>提示：负载均衡由参数 balance 控制，决定开启/关闭自动负载均衡。</strong></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="数据写入与复制流程"><a class="anchor" id="replication"></a>数据写入与复制流程<a class="hash-link" href="#数据写入与复制流程" title="Direct link to heading">​</a></h2><p>如果一个数据库有 N 个副本，那一个虚拟节点组就有 N 个虚拟节点，但是只有一个是 master，其他都是 slave。当应用将新的记录写入系统时，只有 master vnode 能接受写的请求。如果 slave vnode 收到写的请求，系统将通知 taosc 需要重新定向。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="master-vnode-写入流程">Master Vnode 写入流程<a class="hash-link" href="#master-vnode-写入流程" title="Direct link to heading">​</a></h3><p>Master Vnode 遵循下面的写入流程：</p><p><img alt="TDengine Master写入流程" src="/tddocs/assets/images/write_master-e8f03c648c18dc17e2bad7355f21a8f8.png" width="1185" height="589"></p><center> 图 3 TDengine Master 写入流程  </center><ol><li>master vnode 收到应用的数据插入请求，验证OK，进入下一步；</li><li>如果系统配置参数 walLevel 大于 0，vnode 将把该请求的原始数据包写入数据库日志文件 WAL。如果 walLevel 设置为 2，而且 fsync 设置为 0，TDengine 还将 WAL 数据立即落盘，以保证即使宕机，也能从数据库日志文件中恢复数据，避免数据的丢失；</li><li>如果有多个副本，vnode 将把数据包转发给同一虚拟节点组内的 slave vnodes, 该转发包带有数据的版本号(version)；</li><li>写入内存，并将记录加入到 skip list；</li><li>master vnode 返回确认信息给应用，表示写入成功。</li><li>如果第 2、3、4 步中任何一步失败，将直接返回错误给应用。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="slave-vnode-写入流程">Slave Vnode 写入流程<a class="hash-link" href="#slave-vnode-写入流程" title="Direct link to heading">​</a></h3><p>对于 slave vnode，写入流程是：</p><p><img alt="TDengine Slave 写入流程" src="/tddocs/assets/images/write_slave-69b190691edf09e0e009bbcd3a25a0b0.png" width="1185" height="449"></p><center> 图 4 TDengine Slave 写入流程  </center><ol><li>slave vnode 收到 Master vnode 转发了的数据插入请求。检查 last version 是否与 master 一致，如果一致，进入下一步。如果不一致，需要进入同步状态。</li><li>如果系统配置参数 walLevel 大于 0，vnode 将把该请求的原始数据包写入数据库日志文件 WAL。如果 walLevel 设置为 2，而且 fsync 设置为 0，TDengine 还将 WAL 数据立即落盘，以保证即使宕机，也能从数据库日志文件中恢复数据，避免数据的丢失。</li><li>写入内存，更新内存中的 skip list。</li></ol><p>与 master vnode 相比，slave vnode 不存在转发环节，也不存在回复确认环节，少了两步。但写内存与 WAL 是完全一样的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="主从选择">主从选择<a class="hash-link" href="#主从选择" title="Direct link to heading">​</a></h3><p>Vnode 会保持一个数据版本号(version)，对内存数据进行持久化存储时，对该版本号也进行持久化存储。每个数据更新操作，无论是采集的时序数据还是元数据，这个版本号将增加 1。</p><p>一个 vnode 启动时，角色(master、slave) 是不定的，数据是处于未同步状态，它需要与虚拟节点组内其他节点建立 TCP 连接，并互相交换 status，其中包括 version 和自己的角色。通过 status 的交换，系统进入选主流程，规则如下：</p><ol><li>如果只有一个副本，该副本永远就是 master</li><li>所有副本都在线时，版本最高的被选为 master</li><li>在线的虚拟节点数过半，而且有虚拟节点是 slave 的话，该虚拟节点自动成为 master</li><li>对于 2 和 3，如果多个虚拟节点满足成为 master 的要求，那么虚拟节点组的节点列表里，最前面的选为 master</li></ol><p>更多的关于数据复制的流程，请见<a href="https://www.taosdata.com/cn/documentation/architecture/replica/" target="_blank" rel="noopener noreferrer">TDengine 2.0 数据复制模块设计</a>。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="同步复制">同步复制<a class="hash-link" href="#同步复制" title="Direct link to heading">​</a></h3><p>对于数据一致性要求更高的场景，异步数据复制无法满足要求，因为有极小的概率丢失数据，因此 TDengine 提供同步复制的机制供用户选择。在创建数据库时，除指定副本数 replica 之外，用户还需要指定新的参数 quorum。如果 quorum 大于1，它表示每次master转发给副本时，需要等待 quorum-1 个回复确认，才能通知应用，数据在 slave 已经写入成功。如果在一定的时间内，得不到 quorum-1 个回复确认，master vnode 将返回错误给应用。</p><p>采用同步复制，系统的性能会有所下降，而且 latency 会增加。因为元数据要强一致，mnode 之间的数据同步缺省就是采用的同步复制。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="缓存与持久化"><a class="anchor" id="persistence"></a>缓存与持久化<a class="hash-link" href="#缓存与持久化" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="缓存">缓存<a class="hash-link" href="#缓存" title="Direct link to heading">​</a></h3><p>TDengine 采用时间驱动缓存管理策略（First-In-First-Out，FIFO），又称为写驱动的缓存管理机制。这种策略有别于读驱动的数据缓存模式（Least-Recent-Used，LRU），直接将最近写入的数据保存在系统的缓存中。当缓存达到临界值的时候，将最早的数据批量写入磁盘。一般意义上来说，对于物联网数据的使用，用户最为关心的是刚产生的数据，即当前状态。TDengine 充分利用这一特性，将最近到达的（当前状态）数据保存在缓存中。</p><p>TDengine 通过查询函数向用户提供毫秒级的数据获取能力。直接将最近到达的数据保存在缓存中，可以更加快速地响应用户针对最近一条或一批数据的查询分析，整体上提供更快的数据库查询响应能力。从这个意义上来说，<strong>可通过设置合适的配置参数将 TDengine 作为数据缓存来使用，而不需要再部署 Redis 或其他额外的缓存系统</strong>，可有效地简化系统架构，降低运维的成本。需要注意的是，TDengine 重启以后系统的缓存将被清空，之前缓存的数据均会被批量写入磁盘，缓存的数据将不会像专门的 key-value 缓存系统再将之前缓存的数据重新加载到缓存中。</p><p>每个 vnode 有自己独立的内存，而且由多个固定大小的内存块组成，不同 vnode 之间完全隔离。数据写入时，类似于日志的写法，数据被顺序追加写入内存，但每个 vnode 维护有自己的 skip list，便于迅速查找。当三分之一以上的内存块写满时，启动落盘操作，而且后续写的操作在新的内存块进行。这样，一个 vnode 里有三分之一内存块是保留有最近的数据的，以达到缓存、快速查找的目的。一个 vnode 的内存块的个数由配置参数 blocks 决定，内存块的大小由配置参数 cache 决定。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="持久化存储">持久化存储<a class="hash-link" href="#持久化存储" title="Direct link to heading">​</a></h3><p>TDengine 采用数据驱动的方式让缓存中的数据写入硬盘进行持久化存储。当 vnode 中缓存的数据达到一定规模时，为了不阻塞后续数据的写入，TDengine 也会拉起落盘线程将缓存的数据写入持久化存储。TDengine 在数据落盘时会打开新的数据库日志文件，在落盘成功后则会删除老的数据库日志文件，避免日志文件无限制地增长。</p><p>为充分利用时序数据特点，TDengine 将一个 vnode 保存在持久化存储的数据切分成多个文件，每个文件只保存固定天数的数据，这个天数由系统配置参数 days 决定。切分成多个文件后，给定查询的起止日期，无需任何索引，就可以立即定位需要打开哪些数据文件，大大加快读取速度。</p><p>对于采集的数据，一般有保留时长，这个时长由系统配置参数 keep 决定。超过这个设置天数的数据文件，将被系统自动删除，释放存储空间。</p><p>给定 days 与 keep 两个参数，一个典型工作状态的 vnode 中总的数据文件数为：<code>向上取整(keep/days)+1</code>个。总的数据文件个数不宜过大，也不宜过小。10到100以内合适。基于这个原则，可以设置合理的 days。目前的版本，参数 keep 可以修改，但对于参数 days，一旦设置后，不可修改。</p><p>在每个数据文件里，一张表的数据是一块一块存储的。一张表可以有一到多个数据文件块。在一个文件块里，数据是列式存储的，占用的是一片连续的存储空间，这样大大提高读取速度。文件块的大小由系统参数 maxRows （每块最大记录条数）决定，缺省值为 4096。这个值不宜过大，也不宜过小。过大，定位具体时间段的数据的搜索时间会变长，影响读取速度；过小，数据块的索引太大，压缩效率偏低，也影响读取速度。</p><p>每个数据文件(.data 结尾)都有一个对应的索引文件（.head 结尾），该索引文件对每张表都有一数据块的摘要信息，记录了每个数据块在数据文件中的偏移量，数据的起止时间等信息，以帮助系统迅速定位需要查找的数据。每个数据文件还有一对应的 last 文件(.last 结尾)，该文件是为防止落盘时数据块碎片化而设计的。如果一张表落盘的记录条数没有达到系统配置参数 minRows（每块最小记录条数），将被先存储到 last 文件，等下次落盘时，新落盘的记录将与 last 文件的记录进行合并，再写入数据文件。</p><p>数据写入磁盘时，根据系统配置参数 comp 决定是否压缩数据。TDengine 提供了三种压缩选项：无压缩、一阶段压缩和两阶段压缩，分别对应 comp 值为 0、1 和 2 的情况。一阶段压缩根据数据的类型进行了相应的压缩，压缩算法包括 delta-delta 编码、simple 8B 方法、zig-zag 编码、LZ4 等算法。二阶段压缩在一阶段压缩的基础上又用通用压缩算法进行了压缩，压缩率更高。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="多级存储">多级存储<a class="hash-link" href="#多级存储" title="Direct link to heading">​</a></h3><p>说明：多级存储功能仅企业版支持，从 2.0.16.0 版本开始提供。</p><p>在默认配置下，TDengine 会将所有数据保存在 /var/lib/taos 目录下，而且每个 vnode 的数据文件保存在该目录下的不同目录。为扩大存储空间，尽量减少文件读取的瓶颈，提高数据吞吐率 TDengine 可通过配置系统参数 dataDir 让多个挂载的硬盘被系统同时使用。</p><p>除此之外，TDengine 也提供了数据分级存储的功能，将不同时间段的数据存储在挂载的不同介质上的目录里，从而实现不同“热度”的数据存储在不同的存储介质上，充分利用存储，节约成本。比如，最新采集的数据需要经常访问，对硬盘的读取性能要求高，那么用户可以配置将这些数据存储在 SSD 盘上。超过一定期限的数据，查询需求量没有那么高，那么可以存储在相对便宜的 HDD 盘上。</p><p>多级存储支持3级，每级最多可配置 16 个挂载点。</p><p>TDengine 多级存储配置方式如下（在配置文件/etc/taos/taos.cfg中）：</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dataDir [path] &lt;level&gt; &lt;primary&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ul><li>path: 挂载点的文件夹路径</li><li>level: 介质存储等级，取值为 0，1，2。<br>0级存储最新的数据，1级存储次新的数据，2级存储最老的数据，省略默认为 0。<br>各级存储之间的数据流向：0 级存储 -&gt; 1 级存储 -&gt; 2 级存储。<br>同一存储等级可挂载多个硬盘，同一存储等级上的数据文件分布在该存储等级的所有硬盘上。<br>需要说明的是，数据在不同级别的存储介质上的移动，是由系统自动完成的，用户无需干预。</li><li>primary: 是否为主挂载点，0（否）或 1（是），省略默认为 1。</li></ul><p>在配置中，只允许一个主挂载点的存在（level=0, primary=1），例如采用如下的配置方式：</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data1 0 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data2 0 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data3 1 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data4 1 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data5 2 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dataDir /mnt/data6 2 0</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>注意：</p><ol><li>多级存储不允许跨级配置，合法的配置方案有：仅 0 级，仅 0 级+ 1 级，以及 0 级+ 1 级+ 2 级。而不允许只配置 level=0 和 level=2，而不配置 level=1。</li><li>禁止手动移除使用中的挂载盘，挂载盘目前不支持非本地的网络盘。</li><li>多级存储目前不支持删除已经挂载的硬盘的功能。</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="数据查询"><a class="anchor" id="query"></a>数据查询<a class="hash-link" href="#数据查询" title="Direct link to heading">​</a></h2><p>TDengine 提供了多种多样针对表和超级表的查询处理功能，除了常规的聚合查询之外，还提供针对时序数据的窗口查询、统计聚合等功能。TDengine 的查询处理需要客户端、vnode、mnode 节点协同完成。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="单表查询">单表查询<a class="hash-link" href="#单表查询" title="Direct link to heading">​</a></h3><p>SQL 语句的解析和校验工作在客户端完成。解析 SQL 语句并生成抽象语法树(Abstract Syntax Tree, AST)，然后对其进行校验和检查。以及向管理节点(mnode)请求查询中指定表的元数据信息(table metadata)。</p><p>根据元数据信息中的 End Point 信息，将查询请求序列化后发送到该表所在的数据节点（dnode）。dnode 接收到查询请求后，识别出该查询请求指向的虚拟节点（vnode），将消息转发到 vnode 的查询执行队列。vnode 的查询执行线程建立基础的查询执行环境，并立即返回该查询请求，同时开始执行该查询。</p><p>客户端在获取查询结果的时候，dnode 的查询执行队列中的工作线程会等待 vnode 执行线程执行完成，才能将查询结果返回到请求的客户端。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="按时间轴聚合降采样插值">按时间轴聚合、降采样、插值<a class="hash-link" href="#按时间轴聚合降采样插值" title="Direct link to heading">​</a></h3><p>时序数据有别于普通数据的显著特征是每条记录均具有时间戳，因此针对具有时间戳的数据在时间轴上进行聚合是不同于普通数据库的重要功能。从这点上来看，与流计算引擎的窗口查询有相似的地方。</p><p>在 TDengine 中引入关键词 interval 来进行时间轴上固定长度时间窗口的切分，并按照时间窗口对数据进行聚合，对窗口范围内的数据按需进行聚合。例如：</p><div class="codeBlockContainer_I0IT language-sql theme-code-block"><div class="codeBlockContent_wNvx sql"><pre tabindex="0" class="prism-code language-sql codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">COUNT</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> d1001 </span><span class="token keyword" style="color:#00009f">INTERVAL</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token plain">h</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>针对 d1001 设备采集的数据，按照1小时的时间窗口返回每小时存储的记录数量。</p><p>在需要连续获得查询结果的应用场景下，如果给定的时间区间存在数据缺失，会导致该区间数据结果也丢失。TDengine 提供策略针对时间轴聚合计算的结果进行插值，通过使用关键词 fill 就能够对时间轴聚合结果进行插值。例如：</p><div class="codeBlockContainer_I0IT language-sql theme-code-block"><div class="codeBlockContent_wNvx sql"><pre tabindex="0" class="prism-code language-sql codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">COUNT</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> d1001 </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> ts </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;2017-7-14 00:00:00&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">AND</span><span class="token plain"> ts </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;2017-7-14 23:59:59&#x27;</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">INTERVAL</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token plain">h</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> FILL</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">PREV</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>针对 d1001 设备采集数据统计每小时记录数，如果某一个小时不存在数据，则返回之前一个小时的统计数据。TDengine 提供前向插值(prev)、线性插值(linear)、NULL值填充(NULL)、特定值填充(value)。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="多表聚合查询">多表聚合查询<a class="hash-link" href="#多表聚合查询" title="Direct link to heading">​</a></h3><p>TDengine 对每个数据采集点单独建表，但在实际应用中经常需要对不同的采集点数据进行聚合。为高效的进行聚合操作，TDengine 引入超级表（STable）的概念。超级表用来代表一特定类型的数据采集点，它是包含多张表的表集合，集合里每张表的模式（schema）完全一致，但每张表都带有自己的静态标签，标签可以有多个，可以随时增加、删除和修改。应用可通过指定标签的过滤条件，对一个 STable 下的全部或部分表进行聚合或统计操作，这样大大简化应用的开发。其具体流程如下图所示：</p><p><img alt="多表聚合查询原理图" src="/tddocs/assets/images/multi_tables-fab4fa48f633a3ff01f91cd1e225589c.png" width="1114" height="438"></p><center> 图 5 多表聚合查询原理图  </center><ol><li>应用将一个查询条件发往系统；</li><li>taosc 将超级表的名字发往 meta node（管理节点)；</li><li>管理节点将超级表所拥有的 vnode 列表发回 taosc；</li><li>taosc 将计算的请求连同标签过滤条件发往这些 vnode 对应的多个数据节点；</li><li>每个 vnode 先在内存里查找出自己节点里符合标签过滤条件的表的集合，然后扫描存储的时序数据，完成相应的聚合计算，将结果返回给 taosc；</li><li>taosc 将多个数据节点返回的结果做最后的聚合，将其返回给应用。 </li></ol><p>由于 TDengine 在 vnode 内将标签数据与时序数据分离存储，通过在内存里过滤标签数据，先找到需要参与聚合操作的表的集合，将需要扫描的数据集大幅减少，大幅提升聚合计算速度。同时，由于数据分布在多个 vnode/dnode，聚合计算操作在多个 vnode 里并发进行，又进一步提升了聚合的速度。 对普通表的聚合函数以及绝大部分操作都适用于超级表，语法完全一样，细节请看 TAOS SQL。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="预计算">预计算<a class="hash-link" href="#预计算" title="Direct link to heading">​</a></h3><p>为有效提升查询处理的性能，针对物联网数据的不可更改的特点，在数据块头部记录该数据块中存储数据的统计信息：包括最大值、最小值、和。我们称之为预计算单元。如果查询处理涉及整个数据块的全部数据，直接使用预计算结果，完全不需要读取数据块的内容。由于预计算数据量远小于磁盘上存储的数据块数据的大小，对于磁盘 I/O 为瓶颈的查询处理，使用预计算结果可以极大地减小读取 I/O 压力，加速查询处理的流程。预计算机制与 Postgre SQL 的索引 BRIN（block range index）有异曲同工之妙。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/dingbo8128/tddocs/edit/main/docs/architecture/arch.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/tddocs/docs/getting-started/install"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">安装和卸载</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/tddocs/docs/architecture/taosd"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">taosd的设计</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#数据模型" class="table-of-contents__link toc-highlight">数据模型</a><ul><li><a href="#物联网典型场景" class="table-of-contents__link toc-highlight">物联网典型场景</a></li><li><a href="#数据特征" class="table-of-contents__link toc-highlight">数据特征</a></li><li><a href="#关系型数据库模型" class="table-of-contents__link toc-highlight">关系型数据库模型</a></li><li><a href="#一个数据采集点一张表" class="table-of-contents__link toc-highlight">一个数据采集点一张表</a></li><li><a href="#超级表同一类型数据采集点的集合" class="table-of-contents__link toc-highlight">超级表：同一类型数据采集点的集合</a></li></ul></li><li><a href="#集群与基本逻辑单元" class="table-of-contents__link toc-highlight">集群与基本逻辑单元</a><ul><li><a href="#主要逻辑单元" class="table-of-contents__link toc-highlight">主要逻辑单元</a></li><li><a href="#节点之间的通讯" class="table-of-contents__link toc-highlight">节点之间的通讯</a></li><li><a href="#一个典型的消息流程" class="table-of-contents__link toc-highlight">一个典型的消息流程</a></li></ul></li><li><a href="#存储模型与数据分区分片" class="table-of-contents__link toc-highlight"><a class="anchor" id="sharding"></a>存储模型与数据分区、分片</a><ul><li><a href="#存储模型" class="table-of-contents__link toc-highlight">存储模型</a></li><li><a href="#数据分片" class="table-of-contents__link toc-highlight">数据分片</a></li><li><a href="#数据分区" class="table-of-contents__link toc-highlight">数据分区</a></li><li><a href="#负载均衡" class="table-of-contents__link toc-highlight">负载均衡</a></li></ul></li><li><a href="#数据写入与复制流程" class="table-of-contents__link toc-highlight"><a class="anchor" id="replication"></a>数据写入与复制流程</a><ul><li><a href="#master-vnode-写入流程" class="table-of-contents__link toc-highlight">Master Vnode 写入流程</a></li><li><a href="#slave-vnode-写入流程" class="table-of-contents__link toc-highlight">Slave Vnode 写入流程</a></li><li><a href="#主从选择" class="table-of-contents__link toc-highlight">主从选择</a></li><li><a href="#同步复制" class="table-of-contents__link toc-highlight">同步复制</a></li></ul></li><li><a href="#缓存与持久化" class="table-of-contents__link toc-highlight"><a class="anchor" id="persistence"></a>缓存与持久化</a><ul><li><a href="#缓存" class="table-of-contents__link toc-highlight">缓存</a></li><li><a href="#持久化存储" class="table-of-contents__link toc-highlight">持久化存储</a></li><li><a href="#多级存储" class="table-of-contents__link toc-highlight">多级存储</a></li></ul></li><li><a href="#数据查询" class="table-of-contents__link toc-highlight"><a class="anchor" id="query"></a>数据查询</a><ul><li><a href="#单表查询" class="table-of-contents__link toc-highlight">单表查询</a></li><li><a href="#按时间轴聚合降采样插值" class="table-of-contents__link toc-highlight">按时间轴聚合、降采样、插值</a></li><li><a href="#多表聚合查询" class="table-of-contents__link toc-highlight">多表聚合查询</a></li><li><a href="#预计算" class="table-of-contents__link toc-highlight">预计算</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/tddocs/docs/intro">文档</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/tdengine" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/tddocs/blog">博客</a></li><li class="footer__item"><a href="https://github.com/taosdata/TDengine" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">@2022 dingbo8128.github.io 页面内容仅供预览不保证正确性</div></div></div></footer></div>
<script src="/tddocs/assets/js/runtime~main.9709ac72.js"></script>
<script src="/tddocs/assets/js/main.0d693db3.js"></script>
</body>
</html>